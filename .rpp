#!/bin/sh
#
# rperre's PROMPT
# This should be included on your bash profile script
#

# Function to generate PS1 after CMDs
PROMPT_COMMAND=__prompt_command

__prompt_command() {
		# This needs to be first
    local EXIT="$?"

    PS1=""

		### Colors to Vars ### {{{
		## Inspired by http://wiki.archlinux.org/index.php/Color_Bash_Prompt#List_of_colors_for_prompt_and_Bash
		## Terminal Control Escape Sequences: http://www.termsys.demon.co.uk/vtansi.htm
		## Consider using some of: https://gist.github.com/bcap/5682077#file-terminal-control-sh
		## Can unset with `unset -v {,B,U,I,BI,On_,On_I}{Bla,Red,Gre,Yel,Blu,Pur,Cya,Whi} RCol`
		local RCol='\[\e[0m\]'	# Text Reset

		# Regular                    Bold                          Underline                     High Intensity                BoldHigh Intensity             Background                High Intensity Backgrounds
		local Bla='\[\e[0;30m\]';    local BBla='\[\e[1;30m\]';    local UBla='\[\e[4;30m\]';    local IBla='\[\e[0;90m\]';    local BIBla='\[\e[1;90m\]';    local On_Bla='\e[40m';    local On_IBla='\[\e[0;100m\]';
		local Red='\[\e[0;31m\]';    local BRed='\[\e[1;31m\]';    local URed='\[\e[4;31m\]';    local IRed='\[\e[0;91m\]';    local BIRed='\[\e[1;91m\]';    local On_Red='\e[41m';    local On_IRed='\[\e[0;101m\]';
		local Gre='\[\e[0;32m\]';    local BGre='\[\e[1;32m\]';    local UGre='\[\e[4;32m\]';    local IGre='\[\e[0;92m\]';    local BIGre='\[\e[1;92m\]';    local On_Gre='\e[42m';    local On_IGre='\[\e[0;102m\]';
		local Yel='\[\e[0;33m\]';    local BYel='\[\e[1;33m\]';    local UYel='\[\e[4;33m\]';    local IYel='\[\e[0;93m\]';    local BIYel='\[\e[1;93m\]';    local On_Yel='\e[43m';    local On_IYel='\[\e[0;103m\]';
		local Blu='\[\e[0;34m\]';    local BBlu='\[\e[1;34m\]';    local UBlu='\[\e[4;34m\]';    local IBlu='\[\e[0;94m\]';    local BIBlu='\[\e[1;94m\]';    local On_Blu='\e[44m';    local On_IBlu='\[\e[0;104m\]';
		local Pur='\[\e[0;35m\]';    local BPur='\[\e[1;35m\]';    local UPur='\[\e[4;35m\]';    local IPur='\[\e[0;95m\]';    local BIPur='\[\e[1;95m\]';    local On_Pur='\e[45m';    local On_IPur='\[\e[0;105m\]';
		local Cya='\[\e[0;36m\]';    local BCya='\[\e[1;36m\]';    local UCya='\[\e[4;36m\]';    local ICya='\[\e[0;96m\]';    local BICya='\[\e[1;96m\]';    local On_Cya='\e[46m';    local On_ICya='\[\e[0;106m\]';
		local Whi='\[\e[0;37m\]';    local BWhi='\[\e[1;37m\]';    local UWhi='\[\e[4;37m\]';    local IWhi='\[\e[0;97m\]';    local BIWhi='\[\e[1;97m\]';    local On_Whi='\e[47m';    local On_IWhi='\[\e[0;107m\]';
		### End Color Vars ### }}}

		# Checks for git folder
		if [ "$(echo `git rev-parse --git-dir 2> /dev/null;`)"  != "" ]; then
			local isGit=true
		else
			local isGit=false
		fi;

    newline=false
		if [ "$isGit" = true ]; then
			branch=`git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/'`

			modified=`git ls-files -m 2> /dev/null | wc -l`
			untracked=`git ls-files --others --exclude-standard 2> /dev/null | wc -l`
			staged=`git diff --cached --numstat 2> /dev/null | wc -l`
			npushed=`git log --branches --not --remotes 2> /dev/null | grep "commit "| wc -l`

      currentPath=`pwd`

      if [ "$(basename $currentPath)" = ".git" ]; then
        currentPath="$(dirname $currentPath)"
        currentPath="$(basename $currentPath)"
      else
        foldername=$(basename `git rev-parse --show-toplevel` 2>/dev/null)
      fi;

			# Choose branch color
			if [ "$branch" = "master" ]; then
				BCOLOR="${URed}"
			else
				BCOLOR="${Cya}"
			fi;

			PS1+="${RCol}{${BBlu}$foldername${RCol}/${BCOLOR}${branch//[[:blank:]]/}${RCol}} "

			UPSTREAM=${1:-'@{u}'}
			LOCAL=$(git rev-parse @)
			REMOTE=$(git rev-parse "$UPSTREAM")
			BASE=$(git merge-base @ "$UPSTREAM")

			if [ $LOCAL = $REMOTE ]; then
			    PS1+="${Gre}Up-to-date${RCol} "
			elif [ $LOCAL = $BASE ]; then
			    PS1+="${Red}Need to pull${RCol} "
			elif [ $REMOTE = $BASE ]; then
					PS1+="${Cya}Need to push(${BRed}${npushed//[[:blank:]]/}${Cya})${RCol} "
			else
			    PS1+="${On_Red}Diverged${RCol} "
			fi

			if [ "$modified" -gt "0" ]; then
				PS1+="M:${BYel}${modified//[[:blank:]]/}${RCol} "
			fi;

			if [ "$untracked" -gt "0" ]; then
				PS1+="U:${BYel}${untracked//[[:blank:]]/}${RCol} "
			fi;

			if [ "$staged" -gt "0" ]; then
				PS1+="S:${BGre}${staged//[[:blank:]]/}${RCol} "
			fi;

      newline=true
		fi;

    gemcount=`cat Gemfile 2>/dev/null | grep "gem '" | grep -v "#" | wc -l`


    if [ "$gemcount" -gt "0" ]; then

      gemset=`cat .ruby-gemset 2>/dev/null`

      if [ "$gemset" = "" ];then
        gemcolor="${Red}"
        gemset="N/A"
      else
        gemcolor="${BPur}"
      fi;

      rubyversion=`cat .ruby-version 2>/dev/null`

      PS1+="[${gemcolor}${gemset//[[:blank:]]/}${RCol}:${gemcount//[[:blank:]]/}ðŸ’Ž  ${Cya}$rubyversion${RCol}]"

      # too slow
      # check="$(bundle check | grep 'bundle install')"
      # if [ "$check" != "" ]; then
      #   PS1+=" ${Red}bundle install!${RCol}"
      # fi;

      newline=true
    fi;

    if [ "$isGit" = true ]; then
      PS1+="\n"
    fi;

		currentPath=`pwd`

		if [ "$(echo -n $currentPath | wc -m)" -gt "20" ]; then
      D2=$(dirname $currentPath)
      currentPath=$(basename $D2 2>/dev/null)/$(basename $currentPath 2>/dev/null)
      PS1+="$currentPath"
		else
			PS1+="$currentPath"
		fi;

		if [ $EXIT != 0 ]; then
        PS1+="${Red} $ ${RCol}"
    else
        PS1+="${Gre} $ ${RCol}"
    fi
}
#echo -e "âœª Loaded rprompt `cat ~/.rprompt/VERSION`"
echo -e "\033[2mâœª `uptime` \033[0m"
